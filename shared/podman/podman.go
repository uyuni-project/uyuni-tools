package podman

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"
	"text/template"

	"github.com/uyuni-project/uyuni-tools/shared/utils"
)

const UYUNI_NETWORK = "uyuni"
const commonArgs = "--name %s --rm --cap-add NET_RAW --tmpfs /run -v cgroup:/sys/fs/cgroup:rw"

func GetCommonParams(containerName string) []string {
	return strings.Split(fmt.Sprintf(commonArgs, containerName), " ")
}

func GetExposedPorts() []string {
	return []string{"443", "80", "4505", "4506", "69", "25151", "5432", "9100", "9187", "9800"}
}

const ServicePath = "/usr/lib/systemd/system/uyuni-server.service"

func GenerateSystemdService(tz string, image string, podmanArgs []string, verbose bool) {

	setupNetwork(verbose)

	_, err := os.Stat(ServicePath)
	if err == nil {
		log.Fatalln("uyuni-server service already present, not overwriting")
	} else if !os.IsNotExist(err) {
		log.Fatalf("Failed to stat %s file: %s\n", ServicePath, err)
	}

	file, err := os.OpenFile(ServicePath, os.O_WRONLY|os.O_CREATE, 0555)
	if err != nil {
		log.Fatalf("Fail to open uyuni-server.service file: %s\n", err)
	}
	defer file.Close()

	const serviceTemplate = `# uyuni-server.service, generated by uyuniadm
# Use an uyuni-server.service.d/local.conf file to override

[Unit]
Description=Uyuni server image container service
Wants=network.target
After=network-online.target
RequiresMountsFor=%t/containers

[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
Environment=UYUNI_IMAGE={{ .Image }}
Environment=TZ={{ .Timezone }}
Restart=on-failure
ExecStartPre=/bin/rm -f %t/uyuni-server.pid %t/%n.ctr-id
ExecStart=/usr/bin/podman run \
	--conmon-pidfile %t/uyuni-server.pid \
	--cidfile=%t/%n.ctr-id \
	--cgroups=no-conmon \
	--sdnotify=conmon \
	-d \
	{{ .Args }} \
	{{- range .Ports }}
	-p {{ . }}:{{ . }} \
	{{- end }}
	{{- range $name, $path := .Volumes }}
	-v {{ $name }}:{{ $path }} \
	{{- end }}
	-e TZ=${TZ} \
	--network {{ .Network }} \
	${UYUNI_IMAGE}
ExecStop=/usr/bin/podman stop \
	--ignore -t 10 \
	--cidfile=%t/%n.ctr-id
ExecStopPost=/usr/bin/podman rm \
	-f \
	--ignore -t 10 \
	--cidfile=%t/%n.ctr-id

PIDFile=%t/uyuni-server.pid
TimeoutStopSec=180
TimeoutStartSec=900
Type=forking

[Install]
WantedBy=multi-user.target default.target
`

	model := struct {
		Volumes  map[string]string
		Args     string
		Ports    []string
		Timezone string
		Image    string
		Network  string
	}{

		Volumes:  utils.VOLUMES,
		Args:     fmt.Sprintf(commonArgs, "uyuni-server") + " " + strings.Join(podmanArgs, " "),
		Ports:    GetExposedPorts(),
		Timezone: tz,
		Image:    image,
		Network:  UYUNI_NETWORK,
	}

	t := template.Must(template.New("service").Parse(serviceTemplate))
	if err = t.Execute(file, model); err != nil {
		log.Fatalf("Failed to generate systemd service unit file: %s\n", err)
	}

	utils.RunCmd("systemctl", []string{"daemon-reload"}, "Failed to reload systemd daemon", verbose)
}

func setupNetwork(verbose bool) {
	log.Printf("Setting up %s network\n", UYUNI_NETWORK)

	ipv6Enabled := isIpv6Enabled()

	// Check if the uyuni network exists and is IPv6 enabled
	hasIpv6, err := exec.Command("podman", "network", "inspect", "--format", "{{.IPv6Enabled}}", UYUNI_NETWORK).Output()
	if err == nil {
		if string(hasIpv6) != "true" && ipv6Enabled {
			log.Printf("%s network doesn't have IPv6, deleting existing network to enable IPv6 on it\n", UYUNI_NETWORK)
			message := fmt.Sprintf("Failed to remove %s podman network", UYUNI_NETWORK)
			utils.RunCmd("podman", []string{"network", "rm", UYUNI_NETWORK}, message, verbose)
		} else {
			log.Printf("Reusing existing %s network\n", UYUNI_NETWORK)
			return
		}
	}

	message := fmt.Sprintf("Failed to create %s network with IPv6 enabled", UYUNI_NETWORK)

	args := []string{"network", "create"}
	if ipv6Enabled {
		// An IPv6 network on a host where IPv6 is disabled doesn't work: don't try it.
		// Check if the networkd backend is netavark
		out, err := exec.Command("podman", "info", "--format", "{{.Host.NetworkBackend}}").Output()
		backend := strings.Trim(string(out), "\n")
		if err != nil {
			log.Fatalf("Failed to find podman's network backend: %s\n", err)
		} else if backend != "netavark" {
			log.Printf("Podman's network backend (%s) is not netavark, skipping IPv6 enabling on %s network\n", backend, UYUNI_NETWORK)
		} else {
			args = append(args, "--ipv6")
		}
	}
	args = append(args, UYUNI_NETWORK)
	utils.RunCmd("podman", args, message, verbose)
}

func isIpv6Enabled() bool {

	files := []string{
		"/sys/module/ipv6/parameters/disable",
		"/proc/sys/net/ipv6/conf/default/disable_ipv6",
		"/proc/sys/net/ipv6/conf/all/disable_ipv6",
	}

	for _, file := range files {
		// Mind that we are checking disable files, the semantic is inverted
		if getFileBoolean(file) {
			return false
		}
	}
	return true
}

func getFileBoolean(file string) bool {
	out, err := os.ReadFile(file)
	if err != nil {
		log.Fatalf("Failed to read file %s: %s\n", file, err)
	}
	return string(out[:]) != "0"
}
