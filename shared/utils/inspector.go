// SPDX-FileCopyrightText: 2025 SUSE LLC
//
// SPDX-License-Identifier: Apache-2.0

package utils

import (
	"bytes"
	"os"
	"path"
	"strings"

	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	. "github.com/uyuni-project/uyuni-tools/shared/l10n"
	"github.com/uyuni-project/uyuni-tools/shared/templates"
	"github.com/uyuni-project/uyuni-tools/shared/types"
)

// InspectScriptFilename is the inspect script basename.
const InspectScriptFilename = "inspect.sh"

// InspectContainerDirectory represents the directory and the basename where the inspect values are stored.
const (
	InspectContainerDirectory = "/var/lib/uyuni-tools"
	inspectDataFile           = "data"
)

// Inspector implementations can generate a inspection script and parse its results.
// The returned type T depends on the data that are written to the file.
type Inspector[T any] interface {
	// GenerateScript writes the inspection script in ScriptDir.
	GenerateScript() error

	// Read the data generated by the inspection script and unmarshal them an object.
	ReadInspectData() (*T, error)

	// Return the path to the data file.
	GetDataPath() string

	// Return the path to the script file.
	GetScriptPath() string
}

// BaseInspector is offering the basic implementation for the Inspector interface.
type BaseInspector struct {
	ScriptDir string
	DataPath  string
	Values    []types.InspectData
}

// GenerateScriptString creates the inspector script and returns it as a string.
func (i *BaseInspector) GenerateScriptString() (string, error) {
	data := templates.InspectTemplateData{
		Param:      i.Values,
		OutputFile: i.GetDataPath(),
	}

	scriptBuilder := new(strings.Builder)
	if err := data.Render(scriptBuilder); err != nil {
		return "", err
	}

	return scriptBuilder.String(), nil
}

// GenerateScript is a common implementation for all inspectors.
func (i *BaseInspector) GenerateScript() error {
	log.Debug().Msgf("Generating inspect script in %s", i.GetScriptPath())
	data := templates.InspectTemplateData{
		Param:      i.Values,
		OutputFile: i.GetDataPath(),
	}

	if err := WriteTemplateToFile(data, i.GetScriptPath(), 0o555, true); err != nil {
		return Error(err, L("failed to generate inspect script"))
	}
	return nil
}

// GetDataPath returns the path to the data file.
func (i *BaseInspector) GetDataPath() string {
	if i.DataPath != "" {
		return i.DataPath
	}
	return path.Join(i.ScriptDir, inspectDataFile)
}

// GetScriptPath returns the path to the script file.
func (i *BaseInspector) GetScriptPath() string {
	return path.Join(i.ScriptDir, InspectScriptFilename)
}

// ReadInspectData returns an unmarshalled object of type T from the data file.
//
// This function is most likely to be used for the implementation of the inspectors, but can also be used directly.
func ReadInspectData[T any](dataFile string) (*T, error) {
	log.Debug().Msgf("Trying to read %s", dataFile)
	data, err := os.ReadFile(dataFile)
	if err != nil {
		return nil, Errorf(err, L("cannot read file %s"), dataFile)
	}

	return ReadInspectDataString[T](data)
}

// ReadInspectDataString returns an unmarshalled object of type T from the data as a string.
//
// This function is most likely to be used for the implementation of the inspectors, but can also be used directly.
func ReadInspectDataString[T any](data []byte) (*T, error) {
	viper.SetConfigType("env")
	if err := viper.MergeConfig(bytes.NewBuffer(data)); err != nil {
		return nil, Error(err, L("cannot read config"))
	}

	var inspectResult T
	if err := viper.Unmarshal(&inspectResult); err != nil {
		return nil, Error(err, L("failed to unmarshal the inspected data"))
	}
	return &inspectResult, nil
}
